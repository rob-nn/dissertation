\section[COMPONENTES, FRAMEWORKS E FERRAMENTAS]{COMPONENTES, \emph{FRAMEWORKS} E FERRAMENTAS}
Neste item serão analisados os components, \emph{frameworks} e ferramentas que foram selecionadas para construção do \emph{Open Gait Analytics}. 
Este software será um serviço disponibilizado via \emph{web}, sendo assim, estas tecnologias são próprias para este fim. 

\subsection{APLICAÇÕES WEB COM \emph{ANGULAJS}}
\label{angularjs}
O \emph{AngularJS} é um \emph{framework} de aplicação \emph{web}. 
Ele foi projetado especificamente para rodar em \emph{browsers} que suportam \emph{HTML 5}.
Ele também é adequado a criação de aplicações \emph{web} que rodam em \emph{smartphones}. 
É um \emph{framework} bastante completo e rico para sua finalidade. 
A referência \cite{Branas2014} é um guia introdutório conciso no assunto.
 Segundo \cite{Freeman2014}, outro guia no assunto, o \emph{AngularJS} se baseia no padrão de projeto \emph{Model-View-Controller (MVC)} e sua enfase é em permitir a criação de aplicações: extensíveis, manuteníveis, testáveis e padronizadas. 
A Figura \ref{angularjs_mvc} mostra uma representação de uma aplicação fazendo uso do \emph{AngularJS}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=14cm]{figuras/angulajs_mvc.eps}
	\caption{Diagrama de uma aplicação \emph{MVC} usando \emph{AngularJS}.}
	\label{angularjs_mvc}
	\footnotesize Fonte:
	\cite{Williamson2015}.
\end{figure}
Segundo \cite{Williamson2015}, a Figura \ref{angularjs_mvc} mostra o diagrama de uma aplicação \emph{AngularJS} e os componentes \emph{MVC}.  Uma vez que a apliação é lançada, os componentes \emph{model, view} e \emph{controller}, juntamente com todos os documentos \emph{HTML} são carregados no \emph{desktop} ou \emph{smartphone} do usuário e rodam completamente num destes hardwares.  A aplicação \emph{AngularJS} conversa com o \emph{backend} via o protocolo \emph{http}.  O \emph{backend} é um servidor \emph{web} que mantém chamadas \emph{REST} (explicado na seção \ref{servicos_rest}), sendo responsável pela execução da lógica e de processos de negócio.  
Outra característica bastante apreciada pelos desenvolvedores que usam \emph{AngularJS}, é a possibilidade de criar \emph{single-page aplications (SPA)}. 
\emph{SPAs} são aplicações que tem uma página \emph{HTML} de entrada. 
Esta página tem seu conteúdo dinamicamente adicionado e removido da mesma.
Esta abordagem permite criar aplicações bastante interativas, lembrando mesmo, aplicações \emph{desktop} escritas em linguagens como \emph{Visual Basic} e \emph{Delphi}.

\subsection{ORGANIZAÇÃO DE PROJETOS WEB COM \emph{ANGULAR-SEED}}.
\label{angular_seed}

O \emph{angular-seed}, é um \emph{template} para projetos \emph{web} que utilizam o \emph{AngularJS}. 
Ele facilita bastante o processo de configuração e padronização do projeto. 
Ele cria um \emph{layout} de diretórios padronizado, préconfigura a ferramentas de \emph{build} e também já préconfigura o ambiente de testes unitários \emph{web/javascript} usando a ferramenta \emph{JASMINE}. 
Mais informações sobre o \emph{angular-seed} em \cite{Google2015b}.

\subsection{SOLUÇÃO DE DESIGN WEB COM \emph{ANGULAR-MATERIAL}}
\label{angular_material}

Os usuários profissionais da área de saúde, dificilmente se interessariam por um software complexo sem uma interface atraente e amigável.
Uma solução para minimizar este problema é a adoção da  biblioteca \emph{angular-material}. 
Esta biblioteca, como indicado pelo seu nome, é construída com o \emph{AngularJS}. 
Ela disponibiliza serviços e diretivas que podem ser usados para construir a interface gráfica da aplicação. 
Diretivas são componentes que podem ser inseridos diretamente no código HTML da aplicação, dando a aparência de estender a própria HTML. 
Por exemplo, a diretiva \emph{md-button} da biblioteca é um tipo de botão que não é próprio do HTML. 
Outros exemplos de diretivas são: caixas de diálogos, barras de ferramentas, barras de progresso, grades, \emph{tooltip}, etc. 
Esta biblioteca é baseada na especificação \emph{Material Design} criada pela empresa \emph{Google}. 
A especificação discorre sobre padrões de designe gráfico e interação com usuário e é baseada no princípio da metáfora de materiais. 
Esta metáfora é uma teoria unificada de um espaço racionalizado e sistemas de movimento, isto segundo \cite{Google2015a}. Outra vantagem da biblioteca é que ela é projetada para se adaptar a diferentes tipos de dispositivos com telas de tamanhos diferentes.


\subsection{GRÁFICOS E ANIMAÇÕES 3D NA \emph{WEB} COM \emph{THREEJS}} 
Os \emph{browsers} modernos hoje, inclusive os dos \emph{smartphones}, suportam o novo padrão \emph{WebGL}. 
Este é um padrão \emph{web} multi-plataforma de \emph{API)} de baixo nível para gráficos 3D, expostos através de \emph{HTML}. 
Este padrão suporta o acesso da \emph{API} usando-se a linguagem \emph{GLSL}. 
Uma vantagem desta API é que ela suporta nativamente \emph{GPUs} disponibilizadas pelo hardware que está executando o cliente \emph{web}. 
Isto torna possível até mesmo a criação de jogos de alta definição em 3D que rodam no \emph{browser} \cite{Matsuda2013}.

O problema com a \emph{WebGL} é que, como dito anteriormente, a \emph{API} é de baixo nível. 
No contexto de computação gráfica, isto significa que ela fornece primitivas básicas para modelagem 3D e outras opções de otimização do hardware.
Para resolver este problema bibliotecas em \emph{javascript} foram desenvolvidas, disponibilizando funções e objetos de alto nível, como cilindros, planos, esferas, animações, entre outros. 
Uma opção é o \emph{ThreeJS}, descrito em \cite{Dirksen2015}. 
Esta biblioteca apresenta um grande número de funcionalidades e é possível encontrar aplicações e jogos em 3D de nível profissional. 
Um exemplo de animação renderizada que utiliza \emph{ThreeJS} é mostrada na Figura \ref{evil_eye}.
Mais exemplos podem ser vistos no site \emph{threejs.org}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=14cm]{figuras/evil_eye.eps}
	\caption{Exemplo de aplicação que utiliza \emph{ThreeJS}.}
	\label{evil_eye}
	\footnotesize Fonte: \url{http://www.vill.ee/eye/}.
\end{figure}


\subsection{SERVIÇOS REST COM \emph{FLASK}}
\label{servicos_rest}

O \emph{Representational State Transfer (REST)} foi primeiramente descrito por \cite{Fielding2000}. 
Ele é definido como um estilo arquitetural de sistemas hipermídia e tem as seguintes características descritas por \cite{Grinberg2014}:

\begin{enumerate}
	\item Cliente-Servidor. Há uma separação clara entre quem consome, cliente, e quem serve e executa a lógica de negócio, servidor;
	\item \emph{Stateless}. O cliente precisa incluir nas suas requisições, todas as informações necessárias para o servidor processar o pedido. O servidor não armazena informações de estado do cliente entre as requisições deste;
	\item Interface Uniforme. O protocolo que os clientes usam para acessar o servidor precisa ser consistente, bem definido e padronizado. O protocolo comumente usado por serviços \emph{REST} é o \emph{HTTP};
	\item Sistema em Camadas. Servidores \emph{proxy}, \emph{caches} ou \emph{gateways}, podem ser inseridos entre clientes e servidores quando necessários, para melhorar a performance, confiabilidade e escalabilidade;
	\item Código Sob Demanda. Clientes podem opcionalmente fazer o \emph{download} de código do servidor e executá-lo em seu contexto.
\end{enumerate}

A principal ideia de serviços \emph{REST} é o fornecimento de recursos. 
Por exemplo, o cliente requere um usuário, blog, comentários, entre outros. 
Cada recurso deve possuir uma \emph{URL} que o identifica unicamente, por exemplo, http://www.minhaurl.com.br/usuario/123, onde 123 é um identificador único do usuário.

Para que um serviço \emph{REST} funcione, ele precisa ser implementado para suportar requisições \emph{HTTP}, ou seja, ele teria que ser um servidor \emph{web} completo. 
A biblioteca escolhida para desempenhar esta função foi a \emph{Flask}. 
Esta é uma biblioteca escrita na linguagem \emph{Python} e fornece todos as ferramentas necessárias para criar aplicações \emph{webs}. 
Segundo \cite{Maia2015}, o \emph{Flask} vem sendo adotado, por sua filosofia minimalista que não impõe uma arquitetura específica de projeto, assim permitindo que um projeto comece pequeno e simples, evoluindo para um modelo mais complexo.

